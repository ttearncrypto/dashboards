# Welcome to F9XR's TTEarnCrypto: iCryptos Dashboards
Source Code of Official Dashboards of TTEarnCrypto



Breakdown of the JavaScript logic powering the **F9XR iCryptos Dashboard**.

This dashboard operates as a **Single Page Application (SPA)** running entirely in the browser (Client-Side). It does not require a backend server (Node/Python/PHP) because it fetches data directly from Google Blogger feeds and processes it in the user's browser.

Here are the 6 core components of the engine:

---

### 1. Configuration & State (`CONFIG` & `state`)
The script starts by defining the "rules" and the "memory" of the app.

*   **`CONFIG`**: Holds static settings like the API sources (your Blogger URLs), icons, and how many items to show per page (`itemsPerLoad`). This makes it easy to add new categories without rewriting logic.
*   **`state`**: This is the application's "brain." It tracks:
    *   `rawData`: All data fetched from the API (before filtering).
    *   `filteredData`: The specific data currently being shown (after searching/sorting).
    *   `watchlist`: Items the user has saved (loaded from LocalStorage).
    *   `activeTag`: Which filter button is currently clicked.

### 2. The Data Fetcher (JSONP Technique)
**The Challenge:** You cannot simply use `fetch()` to get data from a Blogger feed due to CORS (Cross-Origin Resource Sharing) security restrictions.

**The Solution (`fetchSource` function):**
The code uses a technique called **JSONP (JSON with Padding)**:
1.  It dynamically creates a `<script>` tag in the HTML.
2.  It sets the `src` of that script to the Blogger feed URL, appending a `?callback=` parameter.
3.  It creates a temporary global function (e.g., `window.ts_cb_12345`).
4.  When the script loads, Blogger returns the data wrapped in that function call.
5.  The app executes the function, captures the data, deletes the script tag, and cleans up.

### 3. Data Normalization (`processEntry`)
Blogger's API returns very messy, nested JSON data (e.g., `entry.title.$t`).
The `processEntry` function acts as a translator. It takes the messy Blogger data and converts it into a clean, usable object:
```javascript
{
    id: "12345",
    title: "Clean Title",
    url: "https://...",
    tags: ["Airdrop", "Verified"],
    date: Date Object
}
```

### 4. The "Brain": Filtering & Sorting (`applyFilters`)
This function runs every time the user types in the search bar, selects a tag, or changes the sort dropdown.
1.  **Search:** It checks if the `searchInput` text exists inside the **Title** OR the **Tags**.
2.  **Tags:** It checks if an `activeTag` is selected and filters out items that don't match.
3.  **Sorting:** It rearranges the array based on the dropdown (Date Newest, Date Oldest, or Alphabetical).
4.  **Result:** It updates `state.filteredData` and triggers a UI refresh.

### 5. Dynamic UI Rendering
The HTML for the cards is not hardcoded; it is generated by JavaScript using Template Literals (backticks `` ` ``).

*   **`renderGrid`**: Loops through the `filteredData`. It handles **Pagination** by only slicing the first 9 (or `itemsPerLoad`) items. When you click "Load More," it increases the slice size and re-renders.
*   **`createCard`**: This generates the HTML string for a single card. It includes logic to:
    *   Add a "Verified" badge if the tags contain the word "Verify".
    *   Check if the item is in the `watchlist` and color the bookmark icon accordingly.
    *   Apply staggered CSS animations (`animation-delay`) so cards cascade in beautifully.

### 6. Local Storage (The Watchlist)
The dashboard remembers saved items even if the user refreshes the page.
*   **`toggleSave`**: Adds or removes an item ID from the `state.watchlist` array.
*   **`localStorage.setItem`**: Converts that array to a string and saves it in the user's browser browser storage.
*   **Export to CSV**: Generates a `.csv` file dynamically in the browser by joining the watchlist array into a comma-separated string and triggering a download.

---

### Summary of User Flow:

1.  **Page Load:** `init()` runs → Renders Sidebar → Calls `loadSource` for the first category.
2.  **Fetching:** `fetchSource` gets data from Blogger via JSONP.
3.  **Processing:** Data is cleaned and stored in `state.rawData`.
4.  **Tags:** `renderTags` looks at all the loaded data and generates filter buttons for unique categories found.
5.  **User Action (Search):** User types "Bitcoin" → `applyFilters` runs → filters `rawData` → updates `filteredData` → calls `renderGrid` → UI updates instantly.

---

![logo](https://i.imgur.com/4y5XU4l.png)
